# common setting
spring:
  application:
    name: PurchaseService
  main:
    web-application-type: servlet
  docker:
    compose:
      enabled: false

  cloud:
    stream:
      defaultBinder: kafka
      bindings:
        #Sender bind channel
        ticket-out-0:
          destination: ticket.exchange  # Kafka Topic
          contentType: application/json
          producer:
            partitionKeyExpression: headers['partitionKey']  # use header's partitionKey
            partitionCount: 1  # Match current topic's partition count
            requiredGroups: ticketSqlSync  # Ensure consumer group exists
      kafka:
        binder:
          brokers: ${KAFKA_BROKERS:kafka-1:9092,kafka-2:9092,kafka-3:9092}
          # Auto create topic with correct partitions
          autoCreateTopics: true
          autoAddPartitions: true
        bindings:
          ticket-out-0: #binding name
            producer:
              configuration:
                acks: all
                enable.idempotence: true
                linger.ms: 5
                batch.size: 65536
                delivery.timeout.ms: 120000

  data:
    redis:
      host: ${SPRING_DATA_REDIS_HOST}
      port: ${SPRING_DATA_REDIS_PORT:6379}
      password: ${SPRING_DATA_REDIS_PASSWORD:}
      timeout: ${SPRING_DATA_REDIS_TIMEOUT:5000}
      lettuce:
        pool:
          max-active: ${SPRING_DATA_REDIS_POOL_MAX_ACTIVE:8}
          max-idle: ${SPRING_DATA_REDIS_POOL_MAX_IDLE:8}
          min-idle: ${SPRING_DATA_REDIS_POOL_MIN_IDLE:0}
          max-wait: ${SPRING_DATA_REDIS_POOL_MAX_WAIT:-1ms}

kafka:
  binding:
    ticket-out: ticket-out-0  # Spring Cloud Stream binding

logging:
  file:
    name: ./logs/purchase-service.log
  level:
    root: INFO
    org.java.purchaseservice: DEBUG

# If warmup Redis with bootstrap value
tickets:
  bootstrap:
    venue-redis: ${TICKETS_BOOTSTRAP_VENUE_REDIS:true}