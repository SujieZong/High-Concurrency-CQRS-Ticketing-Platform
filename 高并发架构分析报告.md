# 高并发票务平台：项目总体规划与路线图
本文档旨在全面梳理高并发票务平台项目的总体目标、当前进展、未来规划以及技术优化方向，作为项目后续开发的核心指导蓝图。

1. 项目愿景与最终目标 (The Goal)
我们的目标是构建一个生产级别的、高并发、高可用的分布式票务系统。该系统不仅能应对类似大型演唱会开票时的流量洪峰，还应具备优秀的扩展性、容错能力和可维护性，其核心架构理念可以轻松移植到其他高并发场景（如秒杀、抢课等）。

核心目标清单 (Main Goals):
- [ ] 🚀 现代化框架升级 (Spring Boot Best Practices):

  - [✓] 数据访问层：已完成从手动 JdbcTemplate 到 Spring Data JPA 的全面迁移。

  - [ ] 配置管理：使用 @ConfigurationProperties 实现类型安全的配置，将配置与代码分离。

  - [ ] 参数校验：在 Controller 层使用 @Valid 注解对输入DTO进行自动化校验。

  - [ ] 业务逻辑：在实体中使用 Java Enum 替代 String 来管理状态，提升类型安全。

- [ ] 🎟️ 核心功能闭环 (Payment Flow):

  - [✓] 已完成 TicketService 的重构，支持同步创建“待支付”订单。

  - [ ] 开发支付接口 (/pay)，模拟用户支付并更新订单状态为 PAID。

  - [ ] 实现基于 Redis Key 过期或延时队列的机制，自动取消超时未支付的订单并释放座位。

- [ ] ⚡ 基础设施升级 (Infrastructure):

  - [ ] 消息队列：将消息中间件从 RabbitMQ 升级到 Kafka 集群，以获得极致的吞吐量和数据持久性。

  - [ ] 数据库与缓存：为 MySQL 和 Redis 搭建高可用集群。

- [ ] ☁️ 云原生部署与测试 (Cloud Native & Testing):

  - [ ] 将整个系统通过 Docker 容器化，并部署到 Azure Kubernetes Service (AKS) 云平台。

  - [ ] 使用 JMeter 在 Azure 云端进行大规模、高并发的压力测试与验证。

- [ ] 🖥️ 丰富的用户体验 (Frontend):

  - [ ] 构建一个支持可视化选座的前端界面（如使用 React 或 Vue）。

  - [ ] 通过 WebSocket 实现座位状态（可选、已锁定、已售）的实时更新。

生产级能力增强 (Advanced Enhancements):
- [ ] 🛡️ 系统高可用保障: 引入 API 网关 (如 Spring Cloud Gateway) 实现统一的路由、限流和熔断。

- [ ] 📊 全面的可观测性: 集成 Prometheus 和 Grafana，建立完善的监控、告警和分布式日志系统。

- [ ] 🔄 全链路幂等性: 确保所有“写”操作（如下单、支付）的幂等性，防止重复处理。

- [ ] ⚙️ 自动化运维: 建立完整的 CI/CD 流程，实现自动化测试和部署。

### 2. 当前项目进度 (Current Progress)
我们已经成功地完成了项目从初始原型到现代化架构的关键转型。这是一个巨大的里程碑。

✅ 已完成 (Completed):
1. 搭建了基于CQRS的初始架构:

  - 使用 TicketingPlatform 作为写模型（Command），RabbitCombinedConsumer 作为读模型（Query）。

  - 成功地将“购票请求”和“数据持久化”通过 RabbitMQ 进行了解耦。

  - 实现了基于 Redis 和 Lua 脚本的、原子性的高并发座位锁定机制，这是整个项目技术含量最高的核心亮点。

  2. 完成了数据访问层的现代化重构 (DAO -> JPA)：

  - 成功将所有 model 类改造为带有关系映射的 JPA 实体 (@Entity)。

  - 使用 Spring Data JPA Repository 彻底替换了手写 SQL 的 JdbcTicketDao，大幅简化了代码，提升了开发效率和健壮性。

  - 清晰地划分了 DTO（数据传输对象）和 Entity（数据库实体）的职责，优化了项目结构。

3. 重构了核心服务以支持支付流程:

  - TicketService 的核心逻辑已从“异步发送消息”重构为“同步创建待支付订单”，为实现支付功能铺平了道路。

  - QueryService 的职责更加明确，专门负责所有读操作，并引入了自定义异常 TicketNotFoundException 来进行专业的错误处理。

### 3. 代码简化与优化建议 (Spring Boot Simplifications)
在我们的重构过程中，大部分代码已经非常现代化了。但仍然有一些地方可以利用 Spring Boot 的特性进行进一步的简化和优化。

🔹 Controller 层：使用 DTO 接收请求体
你当前的 TicketPurchaseController 可能还在接收零散的参数。最佳实践是直接接收一个 DTO 对象。

优化前:
```java
// @PostMapping("/purchase")
// public TicketRespondDTO purchaseTicket(@RequestParam String eventId, ...) { ... }
```

优化后:
```java
@RestController
@RequestMapping("/api/tickets")
@RequiredArgsConstructor
public class TicketPurchaseController {

    private final TicketServiceInterface ticketService;

    // 使用 @RequestBody 将 JSON 请求体自动转换为一个 DTO 对象
    @PostMapping("/purchase")
    public ResponseEntity<TicketRespondDTO> purchaseTicket(@RequestBody TicketPurchaseRequestDTO request) {
        // 1. 在 Controller 层组装 TicketCreationDTO
        TicketCreationDTO creationDTO = new TicketCreationDTO(
            UUID.randomUUID().toString(), // 在服务器端生成唯一ID
            request.getVenueId(),
            request.getEventId(),
            request.getZoneId(),
            request.getColumn(),
            request.getRow(),
            Instant.now() // 在服务器端生成创建时间
        );

        // 2. 调用 Service
        TicketRespondDTO response = ticketService.purchaseTicket(creationDTO);
        return ResponseEntity.ok(response);
    }
}
```

好处：接口更清晰，扩展性更强，并且可以在 TicketPurchaseRequestDTO 上添加 @Valid 注解来进行自动参数校验。

🔹 配置类：利用 @ConfigurationProperties
在你的 RabbitFactory 或其他配置类中，你可能是硬编码了一些配置值。可以把它们提取到 application.yml 中，并通过一个类型安全的配置类来读取。

优化前:
```java
// public class RabbitFactory {
//     public static final String EXCHANGE_NAME = "ticket.exchange";
// }
```

优化后:
application.yml:
```java
rabbitmq-config:
  exchange-name: ticket.exchange
  queues:
    mysql-queue: mysql.queue
```

RabbitMQProperties.java:
```java
@ConfigurationProperties(prefix = "rabbitmq-config")
@Data
public class RabbitMQProperties {
    private String exchangeName;
    private Map<String, String> queues;
}
```

RabbitFactory.java:
```java
@Configuration
@EnableConfigurationProperties(RabbitMQProperties.class)
public class RabbitFactory {
    private final RabbitMQProperties properties;
    // ... 在构造函数中注入 properties 并使用它
}
```

好处：所有配置集中管理，支持不同环境的配置切换，代码更干净。

🔹 实体类：使用 Java Enum 映射 status 字段
我们之前讨论过，这是 VARCHAR 方案的最佳搭档。

优化后:
```java
// 创建一个枚举类
public enum TicketStatus {
    PENDING_PAYMENT,
    PAID,
    CANCELLED
}

// 在 TicketInfo.java 中使用
@Entity
public class TicketInfo {
    // ...
    @Enumerated(EnumType.STRING) // 告诉JPA将Enum映射为字符串
    @Column(name = "status", nullable = false)
    private TicketStatus status;
}
```
好处：在Java代码层面实现了类型安全，杜绝了拼写错误，让代码意图更清晰。